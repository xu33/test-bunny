⸻

输出格式（Output Formats）

输出格式决定 Output 所生成的文件所使用的 容器格式（container format）。Mediabunny 支持很多常用的容器格式，每种格式可能带有格式特定的配置选项和回调。  ￼

通用属性（Output format properties）

所有输出格式共享一些通用属性与方法，你可以在程序里查询这些信息：

format.fileExtension          // 文件扩展名，比如 “.mp4”
format.mimeType               // 基本的 MIME 类型，比如 “video/mp4”
format.getSupportedCodecs()   // 返回所有该格式可支持的 codec 类型
format.getSupportedVideoCodecs()
format.getSupportedAudioCodecs()
format.getSupportedSubtitleCodecs()
format.supportsVideoRotationMetadata  // 是否支持视频的旋转元数据
format.getSupportedTrackCounts()      // 支持的轨道数量上／下限

getSupportedTrackCounts() 返回一个对象，形如：

{
  video: { min: number, max: number },
  audio: { min: number, max: number },
  subtitle: { min: number, max: number },
  total: { min: number, max: number }
}

这些都可以帮助你在运行时判断某个轨道组合／codec 是否可用。  ￼

⸻

附加写入（Append-only writing）

某些输出格式可以配置为 附加写入（append-only） 模式。
	•	在这种模式下，每次写入的字节偏移量正好等于之前写入的字节总数（也就是说不会回头覆写文件中的某个部分）。
	•	这使得与 StreamTarget 搭配使用变得非常方便，可以边生成边上传、支持流式处理。
	•	同时，append-only 模式通常是对网络流式传输或与 Media Source Extensions 结合使用时的理想选择。  ￼

不过，开启 append-only 模式可能限制某些功能（如在写入过程中的动态修改、在中间位置插入元数据等），具体取决于格式和选项。

⸻

各种容器格式支持 & 配置选项

下面是 Mediabunny 支持的主要输出格式，以及它们各自的特殊选项和注意事项。原文中每个格式都附带 TypeScript 类型定义，我也在下面加以说明。

⸻

MP4（ISO BMFF / MP4 容器）

Mediabunny 使用 Mp4OutputFormat 来生成 MP4 文件。 ￼

配置选项类型名：IsobmffOutputFormatOptions，包含以下可选项：

选项	含义 / 行为	备注 / 注意
fastStart	控制元数据（moov 等）在文件中的位置（是否为 Fast Start）	可选值有：false / 'in-memory' / 'reserve' / 'fragmented'  ￼
minimumFragmentDuration	仅在 fastStart = 'fragmented' 时有效：每个 fragment 最少持续时间（秒）	默认为 1 秒  ￼
metadataFormat	写入元数据标签（metadata tags）时使用的格式	可选 'mdir', 'mdta', 'udta', 或 'auto'  ￼
回调选项 onFtyp, onMoov, onMdat, onMoof	针对文件中的 ftyp / moov / mdat / moof 区段，在其写出时触发的回调	回调参数通常包括对应数据的 Uint8Array 与写入位置等信息  ￼

关于 fastStart 的几种模式说明：
	•	false：不启用 Fast Start，把元数据放在文件末尾。这是最省内存、最快的方式。  ￼
	•	'in-memory'：启用 Fast Start，但把媒体数据先缓存在内存中，最后统一写出。这样最终输出支持流式播放，但在写入时消耗更多内存。  ￼
	•	'reserve'：预先在文件开头保留一定空间用于写入元数据。这样可以边写边填充，但你需要预估文件大小或轨道包数，且在 track metadata 上设定 maximumPacketCount。  ￼
	•	'fragmented'：生成分段 MP4（fragmented MP4 / fMP4）。把媒体样本分成多个 fragment，每个 fragment 都带自己的样本 metadata，同时把通用元数据放在文件开头。这有利于流式播放、边下载边播放。它也支持 append-only 写入。  ￼

注意：
	•	fastStart = 'fragmented' 模式通常 需要包缓冲（packet buffering）。因为在写 fragment 的过程中可能需要等轨道数据同步。  ￼
	•	如果 fastStart 设置为 undefined（默认值），则在使用 BufferTarget 时表现得像 'in-memory'，在其他写目标（如 StreamTarget）则表现像 false。  ￼

⸻

QuickTime (.mov)

QuickTime 格式（.mov）与 MP4 很接近。Mediabunny 提供 MovOutputFormat，其选项与 MP4 所使用的 IsobmffOutputFormatOptions 相同。 ￼

你在 .mov 和 .mp4 之间切换时，可以保留很多相同的配置选项，只是容器格式略有不同（兼容性、支持的特性可能有差异）。

⸻

WebM

使用 WebMOutputFormat 可以写出 WebM（基于 Matroska 的视频容器）文件。 ￼

其对应选项类型为 MkvOutputFormatOptions（WebM 与 MKV 在此处共用某些配置）：

选项	含义 / 行为
appendOnly	是否启用 append-only 写入模式（适合流式场景）  ￼
minimumClusterDuration	每个 cluster 最少时长（秒），cluster 是 WebM 中的聚簇单位  ￼
回调选项：onEbmlHeader, onSegmentHeader, onCluster	对应写出 EBML header、Segment header、每个 cluster 的回调

启用 appendOnly = true 时，可支持流式写入，但可能禁用或限制文件寻址 / 时长等特性。 ￼

⸻

Matroska (.mkv)

与 WebM 类似，使用 MkvOutputFormat 输出 .mkv 文件。它使用同样的 MkvOutputFormatOptions 选项结构。 ￼

⸻

Ogg

使用 OggOutputFormat 生成 Ogg 容器格式文件。 ￼

可选项：
	•	onPage：每个 Ogg 页面（page）写出时触发回调，回传页面数据及其写入位置，以及这个页面对应的媒体源（track）信息。 ￼

Ogg 格式默认就支持 append-only 写入。 ￼

⸻

MP3

使用 Mp3OutputFormat 来生成 MP3 文件。 ￼

选项包括：
	•	xingHeader：是否在文件开头写入 Xing 头（一个含有索引与 metadata 的头部结构）。默认 true。 ￼
	•	如果设为 false，则会变为 append-only 模式。 ￼
	•	onXingFrame：在最终生成 Xing 帧时触发回调（如果 xingHeader ≠ false） ￼

注意：由于大多数浏览器不内建支持 MP3 编码，你可能需要使用 Mediabunny 的官方扩展包 @mediabunny/mp3-encoder 来补充 MP3 编码能力。 ￼

⸻

WAVE（.wav）

使用 WavOutputFormat 来写 WAVE 音频文件。 ￼

选项包括：
	•	large：启用后，生成 RF64 格式，允许文件超过 4 GiB 的限制。 ￼
	•	metadataFormat：写 metadata 标签所采用的格式，可能是 'info'（RIFF 的 INFO 列表）或 'id3'（写 ID3 标签块） ￼
	•	onHeader：WAVE 文件头写出时触发回调，回传头部数据及其写入位置。 ￼

⸻

ADTS (.aac)

使用 AdtsOutputFormat 生成 ADTS 格式的 AAC 文件（.aac）。 ￼

选项：
	•	onFrame：每写出一个 ADTS 帧时触发回调，回传帧数据及其写入位置。 ￼

⸻

FLAC

使用 FlacOutputFormat 来生成 FLAC 音频文件（.flac）。 ￼

选项：
	•	onFrame：每写出一个 FLAC 帧时的回调，传出帧数据和写入位置。 ￼

⸻

如果你愿意的话，我也可以把这篇的 注释版中文 做出来（在每个格式后面加上适用场景、优缺点、示例代码等）。要吗？