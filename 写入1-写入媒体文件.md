⸻

写入媒体文件（Writing Media Files）

Mediabunny 让你可以对媒体文件的创建进行精细控制。你可以向同一个文件里添加任意数量的视频、音频、字幕轨道，并精确控制各轨道数据的时间戳。这个库支持 多种输出文件格式，并且通过 “输出目标（Output Target）” 的机制，让你可以选择是一次性在内存中构建整个文件，还是边构建边分块输出，从而支持生成非常大的文件。 ￼

Mediabunny 提供了多层级的 “媒体源（Media Source）” 抽象，它与 WebCodecs API 有很好的整合，同时也允许你自行控制编码流程，既适合常见用途，也能在需要时提供极致灵活性。 ￼

⸻

一、创建输出（Creating an Output）

在 Mediabunny 中，写入媒体文件的中心是 Output 类。每个 Output 实例对应一个你要生成的媒体文件。

你先用期望的文件配置来创建一个 Output 实例。例如：

import { Output, Mp4OutputFormat, BufferTarget } from 'mediabunny';

// 在内存中创建一个 MP4 文件
const output = new Output({
    format: new Mp4OutputFormat(),
    target: new BufferTarget(),
});

	•	可用的输出格式在 “Output Formats” 部分列出。 ￼
	•	可用的输出目标（target）在 “Output Targets” 部分列出。 ￼

创建以后，你可以通过 output.format 和 output.target 来访问这两个属性。 ￼

⸻

二、添加轨道（Adding Tracks）

Output 对象上有几个方法用于添加不同类型的轨道：

output.addVideoTrack(videoSource);
output.addAudioTrack(audioSource);
output.addSubtitleTrack(subtitleSource);

	•	对于每个轨道，都需要你先创建一个对应的 媒体源（media source）。
	•	一个媒体源只能被用于一个轨道，不能重复使用。 ￼

在添加轨道时，你还可以传入一些**轨道元数据（metadata）**选项，例如：

output.addVideoTrack(videoSource, {
    rotation: 90,     // 顺时针旋转 90°
    frameRate: 30,    // 期望帧率为 30 FPS
});
output.addAudioTrack(audioSourceEng, {
    language: 'eng',
    name: 'Developer Commentary',
});
output.addAudioTrack(audioSourceGer, {
    language: 'ger',
});
output.addSubtitleTrack(subtitleSourceEng, { language: 'eng' });
output.addSubtitleTrack(subtitleSourceGer, { language: 'ger' });
output.addSubtitleTrack(subtitleSourceSpa, { language: 'spa' });
output.addSubtitleTrack(subtitleSourceFre, { language: 'fre' });
output.addSubtitleTrack(subtitleSourceIta, { language: 'ita' });

注意：
	•	如果给视频轨道指定了 frameRate，那么所有添加的帧的时间戳和持续时间都会被“对齐（snap）”到这个帧率。这意味着如果你添加帧的速度比这个帧率还快，就可能出现多个帧拥有相同时间戳的情况。 ￼
	•	对于有分数形式（如 29.97 FPS）这种常见帧率，建议你使用精确的分数表达式。 ￼
	•	如果你添加的轨道与当前输出格式不兼容，会抛出错误。要确保轨道属性符合输出格式要求。 ￼

示例：canvas + 麦克风

假设你要创建一个包含视频轨和音频轨的文件：

import { CanvasSource, MediaStreamAudioTrackSource } from 'mediabunny';

// 假设有一个 <canvas> 元素
const videoSource = new CanvasSource(canvasElement, {
    codec: 'avc',
    bitrate: 1e6,  // 1 Mbps
});
const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
const audioTrack = stream.getAudioTracks()[0];
const audioSource = new MediaStreamAudioTrackSource(audioTrack, {
    codec: 'aac',
    bitrate: 128e3,  // 128 kbps
});

output.addVideoTrack(videoSource, { frameRate: 30 });
output.addAudioTrack(audioSource);


⸻

三、设置元数据标签（Metadata Tags）

在开始写入之前，你可以给输出文件添加一些描述性元数据，例如标题、艺术家、封面图像等：

output.setMetadataTags({
    title: 'Big Buck Bunny',
    artist: 'Blender Foundation',
    date: new Date('2008-05-20'),
    images: [{
        data: new Uint8Array([...]),
        mimeType: 'image/jpeg',
        kind: 'coverFront',
    }],
});

注意：这些元数据必须在你调用 output.start() 之前设置。 ￼
更多可写标签的选项请参考文档中 “MetadataTags” 的章节。 ￼

⸻

四、启动写入（Starting an Output）

在添加好所有轨道并设置好元数据后，调用 start() 方法来启动写入进程：

await output.start();

一旦 start() resolve，说明输出已经准备好接收媒体数据。此时你就不能再添加新的轨道了。 ￼

⸻

五、写入媒体数据（Adding Media Data）

在 Output 启动以后，你可以通过各轨道对应的媒体源来把媒体数据“注入”到输出中去。不同的媒体源有不同的 API，但常见形式大致如下：

mediaSource.add(...);

在上面的 canvas + 麦克风示例中：
	•	启动后，麦克风音频会自动流入输出。
	•	你需要定期把 canvas 的帧添加进去：

let framesAdded = 0;
const intervalId = setInterval(() => {
    const timestamp = framesAdded / 30;
    const duration = 1 / 30;

    videoSource.add(timestamp, duration);
    framesAdded++;
}, 1000 / 30);

你可以持续这个过程一段时间来捕获所需的帧。 ￼

⸻

六、最终化输出（Finalizing an Output）

当所有媒体数据都已添加完毕，你需要调用 finalize() 让 Output 完成剩余的编码工作，并把数据写入最终可播放的文件：

await output.finalize();

一旦 resolve，即表示写入结束。 ￼

注意：调用 finalize 之后不能再写入新的媒体数据，否则会抛错。 ￼

示例流程：

clearInterval(intervalId);
audioTrack.stop();

await output.finalize();
const fileBytes = output.target.buffer;  // 例如得到 Uint8Array／ArrayBuffer


⸻

七、取消输出（Canceling an Output）

如果你需要在写入过程中放弃当前输出，可以调用 cancel()：

await output.cancel();

这会释放所有资源（关闭编码器、释放写入器等）。 ￼
在调用 cancel 后继续写数据也会报错。 ￼

例如：

clearInterval(intervalId);
audioTrack.stop();
await output.cancel();
// 输出已被取消


⸻

八、检查输出状态（Checking Output State）

你可以通过 output.state 属性查看当前输出所处的状态：

output.state;  
// 可能的值： 'pending' | 'started' | 'canceled' | 'finalizing' | 'finalized'

每个状态的含义：
	•	pending — 尚未启动或取消，还可以添加轨道
	•	started — 输出已启动，准备接受媒体数据；不能再添加轨道
	•	finalizing — 已调用 finalize、正在收尾；不能再写入新数据
	•	finalized — 输出已完成
	•	canceled — 输出已被取消  ￼

⸻

九、输出目标（Output Targets）

输出目标决定最终输出的数据要写到哪里。Mediabunny 提供了几种目标类型，每种用途不同。 ￼

所有目标都支持一个可选回调 onwrite(start, end)，允许你监视写入哪些字节区间。 ￼

下面是几种常见的目标：

1. BufferTarget

这个目标会把所有数据写入一个连续的、可自动扩展的内存缓冲 ArrayBuffer。使用非常直接：

const output = new Output({
    target: new BufferTarget(),
    // ...
});

	•	在开始阶段 output.target.buffer 是 null，等 finalize() 完成后才有实际数据。 ￼
	•	适用于较小文件（建议小于 ~100 MB），因为所有数据都驻留内存；若文件过大可能导致浏览器崩溃。 ￼
	•	若处理大文件，推荐使用 StreamTarget 等方式。 ￼

2. StreamTarget

这个目标会把输出数据分块（chunk）传出，让你可以把数据写到磁盘、上传网络、缓存等地方。它基于 Streams API。 ￼

你需要提供一个 WritableStream：

import { StreamTarget, StreamTargetChunk } from 'mediabunny';

const writable = new WritableStream({
    write(chunk: StreamTargetChunk) {
        // chunk.data => Uint8Array
        // chunk.position => number（偏移位置）

        // 在这里把它写走
    }
});
const output = new Output({
    target: new StreamTarget(writable),
    // ...
});

每个块（chunk）包含要写的数据 data（Uint8Array）和写入的偏移 position。注意：某些字节区间可能被写入多次，所以不能简单把各块按到达顺序拼接在一起——你必须把每块写到其指定的偏移位置，否则生成的文件可能损坏。 ￼

某些输出格式支持 “append-only” 模式（即每块的偏移都等于所有前块长度之和），在这种情况下拼接是安全的。 ￼

分块模式（Chunked mode）

默认情况下，只要有数据就会立刻发出写入事件。有些格式可能导致每秒写很多次。你可以启用“分块模式”让它在内存中先累积到一定字节数再发出：

new StreamTarget(writable, {
    chunked: true,
    chunkSize: 2 ** 20,  // 可选；默认为 16 MiB
});

背压（Backpressure）

有时候 Output 可能产生数据的速度比你处理写入的速度快。你需要让 Output 放慢节奏以适应写入端。使用 StreamTarget 时，Output 会自动尊重 WritableStream 的背压机制。 ￼

例如：

const writable = new WritableStream({
    write(chunk) {
        // 模拟写入耗时 10 毫秒
        return new Promise(resolve => setTimeout(resolve, 10));
    }
});

要让背压正确“传导”，还需确保上游媒体源也能响应背压机制。 ￼

与本地文件系统 API 一起用

StreamTargetChunk 设计时就考虑兼容 FileSystemWritableFileStream。你可以将数据直接写到本地磁盘：

const handle = await window.showSaveFilePicker();
const writableStream = await handle.createWritable();

const output = new Output({
    target: new StreamTarget(writableStream),
    // ...
});
await output.finalize();  // finalize 会自动关闭 writableStream

3. FilePathTarget

这个目标用于服务器端（Node、Deno、Bun 等环境），直接写入文件路径，API 更简单。 ￼

import { FilePathTarget } from 'mediabunny';

const output = new Output({
    target: new FilePathTarget('/path/to/output.mp4'),
    // ...
});
await output.finalize();

内部会自动关闭文件句柄。 ￼

这一目标默认也是分块写入模式，你可以配置是否禁用 chunk 或改块大小。 ￼

4. NullTarget

这个目标会直接丢弃所有写入的数据，不保存。这适合你不想生成完整文件、而是通过格式回调或编码器事件来获取数据的场景。 ￼

例如，如果你想创建一个分段的 MP4，并直接处理每个分段：

import { NullTarget, Mp4OutputFormat } from 'mediabunny';

let ftyp: Uint8Array;
let lastMoof: Uint8Array;

const output = new Output({
    target: new NullTarget(),
    format: new Mp4OutputFormat({
        fastStart: 'fragmented',
        onFtyp: (data) => {
            ftyp = data;
        },
        onMoov: (data) => {
            const header = new Uint8Array(ftyp.length + data.length);
            header.set(ftyp, 0);
            header.set(data, ftyp.length);
            // 在这里处理 header
        },
        onMoof: (data) => {
            lastMoof = data;
        },
        onMdat: (data) => {
            const segment = new Uint8Array(lastMoof.length + data.length);
            segment.set(lastMoof, 0);
            segment.set(data, lastMoof.length);
            // 处理这个 segment …
        },
    }),
});

这样你可以在回调里拿到 ftyp、moov、moof、mdat 等数据来手工组装或处理。 ￼

⸻

十、包缓冲 / 数据缓冲（Packet Buffering）

某些输出格式在处理多个轨道时需要 包缓冲（packet buffering）。其原因在于 Output 需要等所有轨道在某个时间戳上的数据都到达后，才能继续写入。例如：你先把所有视频编码完再编码音频，那 Output 可能得把视频数据全缓存在内存里，直到音频数据到来。若你的媒体很长，这就可能耗尽内存。 ￼

如果输出里只有单条轨道，这个问题就不会出现。 ￼

若你的输出格式配置会触发包缓冲，文档建议你：
	•	尽可能交替（interleave）添加各轨道的数据，从而降低内存占用；例如：先写 10 秒视频 + 10 秒音频，循环写。 ￼
	•	若无法交替写入，可以考虑先写总体体量较小的轨道（例如音频）再写较大的轨道（视频），以缓减内存压力。 ￼

⸻

十一、获取输出的 MIME 类型（Output MIME Type）

在一些场景下（比如与 Media Source Extensions 一起使用），你可能需要获取最终输出文件的完整 MIME 类型（包括 codec 字符串）：

output.getMimeType();  // 返回 Promise<string>

这个 Promise 会在所有轨道 codec 字符串确定后 resolve，可能得到类似：

video/mp4; codecs="avc1.42c032, mp4a.40.2"

￼

警告：getMimeType() 可能需要等所有编码器初始化完成才能知道各轨道 codec。因此，如果你在添加媒体数据之前就 await output.getMimeType()，可能会导致这个 Promise 永远不 resolve（死锁）。 ￼

如果你并不关心每条轨道的 codec 字符串，可以直接使用 output.format.mimeType 属性获取更简单的 MIME 类型字符串。 ￼

⸻

如果你愿意的话，我还可以帮你做一份该文档的 注释版中文版（在关键点加上解释、示意图、注意事项等），或者只重点翻译你感兴趣的部分。要继续吗？