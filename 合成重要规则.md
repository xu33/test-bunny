这是一个非常关键的区分！它区分了 **实时预览（Preview）** 和 **最终视频合成（Synthesis/Export）** 两种截然不同的工作模式。

答案是：**最终合成视频时，总是采用“基于固定时间步长的逐帧计算和插入”的方式。**

我们永远不能依赖“按时间播放然后取当前帧”的方法来导出最终文件，因为这会导致时间不精确和质量不稳定。

---

## 区分两种模式：预览 vs. 合成

### 模式一：实时预览 (Real-Time Preview)

| 特征 | 描述 |
| :--- | :--- |
| **工作方式** | **按时间播放然后取当前帧** (近似)。由浏览器或系统的实时时钟驱动。|
| **时钟源** | `performance.now()` 或 `requestAnimationFrame` 的时间戳。|
| **目的** | 以人眼可接受的速度，近似模拟最终效果。|
| **缺点** | **不确定性：** 如果 CPU 负荷过高，可能会跳过（丢弃）帧，导致预览不流畅或时间不准确。因此，它**不能**用于精确的最终导出。|

### 模式二：最终合成 (Final Synthesis/Export)

| 特征 | 描述 |
| :--- | :--- |
| **工作方式** | **基于固定时间步长的逐帧遍历和计算**。|
| **时钟源** | **虚拟时钟：** 从 $0\text{ms}$ 开始，以固定的帧率增量（如 $33.33\text{ms}$ for 30 FPS）步进。|
| **目的** | 保证输出文件具有**精确的帧率**和**完美的计时精度**。|
| **优点** | **确定性：** 无论系统有多慢，都不会丢帧，只是导出时间会延长。每一帧都经过精确计算。|

---

## 🎥 最终合成的流水线（逐帧计算）

最终导出过程是一个严格的、非实时的计算过程，由一个**虚拟主时钟 (Virtual Master Clock)** 驱动。

假设您的目标输出是 **30 FPS** 的视频：

1.  **定义目标时间戳：** 软件首先根据目标帧率确定所有帧应该出现的时间点。
    * 帧 1 的目标时间 $T_1 = 0\text{ms}$
    * 帧 2 的目标时间 $T_2 = 33.333\text{ms}$
    * 帧 3 的目标时间 $T_3 = 66.666\text{ms}$
    * ... 以此类推，直到视频结束。

2.  **循环遍历（时间轴调度）：** 软件开始从 $T_1$ 遍历到 $T_{\text{end}}$。

3.  **计算当前帧：** 对于每个目标时间 $T_n$，执行以下步骤：
    * **调度 (Traversal & Selection):** 调用您的 `getElementsToRender(elements, T_n)` 函数，找出所有活跃元素，并按 Z-index 排序。
    * **插值 (Interpolation):** 对于每个活跃元素 $E$，计算 $E$ 在 $T_n$ 时刻的精确动画值（位置、旋转、不透明度等）。
    * **解码 (Decoding):** 如果是视频元素，则精确解码源素材在**映射时间** $T_{\text{source}}$ 上的那一帧数据。
    * **合成 (Compositing):** 将所有图层按计算出的变换和像素混合规则，合成为一张完整的 $T_n$ 帧（一个像素矩阵）。

4.  **编码插入：** 将合成后的像素矩阵（帧）喂给视频编码器（如 H.264 或 VP9 编码器）进行压缩，并插入到输出文件中。

**关键点：** 这个过程是完全离线的。即使单帧计算耗时 $100\text{ms}$，它也会保证该帧被标记为 $T_n$ 时刻的画面，并保证下一帧从 $T_{n+1}$ 开始计算。这保证了最终视频的时间精度和帧率的稳定。

对于您的 Web 应用程序，这个 **逐帧计算循环** 通常会在一个 **WebWorker** 中执行，并使用 **FFmpeg.wasm** 或 **WebCodecs** 来完成最终的编码工作。